<!DOCTYPE html>
<html lang="en">

<head>
    <title>Selentic Framework: Overview</title>
</head>

<body>

    <h1 id="selentic-framework">Selentic Framework</h1>
    <p>Selentic Framework is a test automation framework for writing web UI
        tests. It is designed based on Component-Object Model design (COM). It
        aims to help producing test automation codes that are easy to maintain
        and read while enabling ramping up the test automation development
        speed.</p>
    <p>Software development projects incorporate test automation to cut down
        on the technical debt while increasing the quality of their products.
        Causing more technical debt to maintain unstable, inconsistent,
        complicated, hard-to-read test automation code is exactly what we want
        to avoid. This framework was designed and developed to help ensuring the
        test automation code remains easily readable and consistent without
        being unstable and flaky. Being able to maintain and manage test
        automation code efficiently is crucial to the success of any test
        automation project.</p>
    <p>Selentic Framework utilizes <strong><em>Selenium</em></strong> and is
        written in <strong><em>Java</em></strong> (Developed on Java 21).</p>
    <h2 id="feature-highlights">Feature Highlights</h2>
    <ul>
        <li>The Component Object Model design allows custom components that are
            reusable, minimizing re-writing the code to do same or similar actions
            or copying-and-pasting, allowing less code to maintain.</li>
        <li>It was designed to provides library to code in strongly pattern
            based design that are consistent throughout. It makes the codes more
            predictable, legible, and easy to maintain while making it easier to
            spot any abnormality that could cause unexpected behaviors.</li>
        <li>It implements automatic wait allows the code to focus on actions and
            assertions rather than timing, while allowing custom waits for those
            more difficult cases.</li>
        <li>It forces indentations for actions on page, frame, external windows,
            dialog, etc. making it easy to spot where actions are happening.</li>
        <li>It includes selector builder. This allows both CSS selector and
            XPath to be implemented in consistent manner while utilizing code
            highlighting and code suggestions of IDE.</li>
    </ul>
    <h2 id="component-object-model">Component Object Model</h2>
    <p>The Component Object Model (COM) in test automation is a design
        pattern that structures tests around specific, reusable UI components
        rather than entire pages. It is an evolution of the traditional Page
        Object Model (POM), allowing for more modular, maintainable, and
        scalable test frameworks, especially for modern applications with
        dynamic user interfaces.</p>
    <h3 id="key-concept">Key Concept</h3>
    <ul>
        <li><ins>
                <strong>Component Abstraction:</strong>
            </ins>
            <p>In the COM pattern, individual UI elements like buttons, text fields,
                navigation menus, or search bars are treated as independent objects or
                classes. This differs from the traditional POM, where an entire web page
                is represented by a single class.</p>
        </li>
        <li><ins>
                <strong>Encapsulation:</strong>
            </ins>
            <p>Each component class encapsulates its own web elements (locators) and
                the methods (actions) that can be performed on it (e.g.,
                clickLoginButton() within a LoginForm component). This ensures that
                changes to a component’s UI only require updates in one specific
                place.</p>
        </li>
        <li><ins>
                <strong>Reusability:</strong>
            </ins>
            <p>Since components are defined independently, they can be reused across
                multiple pages or even different projects. This reduces code duplication
                and speeds up test development.</p>
        </li>
        <li><ins>
                <strong>Hierarchy:</strong>
            </ins>
            <p>Components can be organized into a hierarchy, with a base component
                defining common methods for all components (e.g., checking visibility or
                existence), which is then extended by specialized components.</p>
        </li>
        <li><ins>
                <strong>Extensibility:</strong>
            </ins>
            <p>If a component’s behavior is slightly different (e.g., wait time
                after entering text into a textbox), a method in a component can be
                overridden to change only that behavior rather than writing the entire
                component class.</p>
        </li>
    </ul>
    <h3 id="benefits">Benefits</h3>
    <ul>
        <li><ins>
                <strong>Improved Maintainability:</strong>
            </ins>
            UI changes only affect the specific component’s class, minimizing the
            need to update numerous test scripts.</li>
        <li><ins>
                <strong>Enhanced Scalability:</strong>
            </ins>
            The modular nature makes it easier to manage a large number of tests and
            components in complex applications.</li>
        <li><ins>
                <strong>Better Readability and Clarity:</strong>
            </ins>
            Tests become easier to read and understand as they interact with
            high-level component methods, freeing the test automation engineer to
            focus on test case design.</li>
    </ul>
    <h3 id="implementation">Implementation</h3>
    <p>The Component Object Model design pattern is often implemented using
        a Page Object Model, where a page object acts as a holder for various
        component objects. This allows test automation engineers to access
        component-specific action methods via the page object, creating a clear
        separation of concerns between test logic, page structure, and
        individual component behavior.</p>
    <h2 id="setting-up-selentic-framework">Setting up Selentic
        Framework</h2>
    <ul>
        <li>Download the latest <strong>selentic-framework.jar</strong> file
            from https://github.com/emwhy/selentic-framework/releases/. The javadoc
            for the framework is packaged in
            <strong><em>selentic-framework-javadoc.jar</em></strong>. When
            configured, the documentation can be shown right from IDE (such as
            IntelliJ).
        </li>
        <li>Move the file to appropriate location in a project directory (i.e.,
            ./lib).</li>
        <li>There are additional packages that Selentic Framework depends on.
            Add reference to these packages. If you are working with Gradle, add
            dependencies to <strong>build.gradle.kts</strong> file.</li>
    </ul>
    <pre><code>dependencies {
    implementation(&quot;org.seleniumhq.selenium:selenium-java:4.+&quot;)
    implementation(&quot;ch.qos.logback:logback-classic:1.5.+&quot;)
    implementation(&quot;ch.qos.logback:logback-core:1.5.+&quot;)
    implementation(&quot;commons-io:commons-io:2.17.+&quot;)
    implementation(&quot;com.typesafe:config:1.4.+&quot;)
}</code></pre>
    <ul>
        <li><strong>selentic-framework-jar</strong> can be added like this.</li>
    </ul>
    <pre><code>    implementation(files(&quot;lib/selentic-framework.jar&quot;));</code></pre>
    <ul>
        <li>Reload your Gradle. You should now be able to use Selentic
            classes.</li>
    </ul>
    <h2 id="configuration-file">Configuration File</h2>
    <p>Selentic configuration file allows setting some configurations before
        tests start.</p>
    <p>Selentic looks for <strong>selentic.conf</strong> file in a
        classpath. If not found, default values are used.</p>
    <p>The following shows the default values that can be modified.</p>
    <pre><code> // Default browser
 browser = &quot;chrome&quot;  // Options: chrome, firefox, safari, edge
 
 // Wait timeout in milliseconds
 wait-timeout-millisec = 5000
 
 // Logging configuration
 log {
     root-dir = &quot;&quot;              // Default is $user.dir/log. Directory where logs are stored. 
     root-log-level = &quot;INFO&quot;         // Log level for root logger (TRACE, DEBUG, INFO, WARN, ERROR)
     selentic-log-level = &quot;DEBUG&quot;      // Log level for Selentic Framework logger (TRACE, DEBUG, INFO, WARN, ERROR)
     keep-duration-min = 0           // How long to keep logs in minutes (0 = will not keep)
 }
</code></pre>
<h2>Notable Classes</h2>
<ul>
    <li><b><a href="org/emwhyware/selentic/lib/Selentic.html">Selentic</a></b>: Provides methods to access WebDriver, methods for screenshot, etc.</li>
    <li><b><a href="org/emwhyware/selentic/lib/ScComponent.html">ScComponent</a></b>: The base of all components.</li>
    <li><b><a href="org/emwhyware/selentic/lib/ScPage.html">ScPage</a></b>: The base of all pages.</li>
    <li><b><a href="org/emwhyware/selentic/lib/ScDialog.html">ScDialog</a></b>: The base of all dialog component.</li>
    <li><b><a href="org/emwhyware/selentic/lib/ScFrame.html">ScFrame</a></b>: Handles frames.</li>
    <li><b><a href="org/emwhyware/selentic/lib/ScWindow.html">ScWindow</a></b>: Manages additional windows.</li>
    <li><b><a href="org/emwhyware/selentic/lib/ScCssSelector.html">ScCssSelector</a></b>: The builder for CSS selector.</li>
    <li><b><a href="org/emwhyware/selentic/lib/ScXPath.html">ScXPath</a></b>: The builder for XPath.</li>
</ul>
</body>

</html>